Collection

데이터 그룹을 의미한다.

다양한 자료구조 형이 제공되는 이유는 데이터의 성질에 따라서 
데이터를 관리(정리)해야 하는 방식이 다르기 때문이다

int 컬렉션을 못만들어서 integer 컬랙션으로 만든다.


List형을 제일 많이 쓰고 그다음에 Map형, 그 다음 Set형


ArrayList<String> arrayList;


arrayList.add("str0"); // 0번 인덱스
arrayList.add("str1"); // 1번 이었지만 arrayList.add(1,"11111"); 이후로 2번이됨. 
arrayList.add("str2"); // 2번이었지만 arrayList.add(1,"11111"); 이후로 3번이 됨.
arrayList.add(1,"11111"); // 넣고싶은 자리, 넣을 값
arrayList.set(1, "str1");    // set 은 값을 수정하는 명령어


일반 for문을 사용할 때

for(int i = 0; i < arrayList.size(); i++){ // .length를 안쓰고 .size() 를 사용한다.
	System.out.printf("%d번째 인덱스 값은 : %s\t", i, arrayList.get(i));
} // arrayList.get(i) 를 사용한다. 많이 사용하니 외워두자.



arrayList.clear(); // arrayList의 모든 데이터 삭제

if(arrayList.size() == 0) {
	System.out.println("arrayList 의 데이터는 없습니다");
if(arrayList.isEmpty()) {
	System.out.println("arrayList 의 데이터가 비워짐");

Map 계열의 자료구조는 인덱스 대신 키 값으로 데이터를 억세스한다.
키값은 유니크해야한다.(중복x)

HashMap 은 int 를 사용할 수 없다. int를 사용하고싶으면 Integer를 사용해야한다.
HashMap 은 for문을 사용할 수 없다.

HashSet 은 정렬이 되지 않는다. 그래서
TreeSet 을 사용한다.
그러나 보통 데이터베이스에서 데이터를 가져오기때문에 TreeSet을 사용하는일은 드물다.


Student s = new Student(6, "이순신");
		student.add(s);
		student.add(s);

이렇게 넣으면 중복에 걸리지만

student.add(new Student(1, "나길동"));
student.add(new Student(1, "나길동"));

이렇게 넣으면 중복에 걸리지않는다. 그래서 아래와 같이 Override를 한다.


@Override
public boolean equals(Object obj) {
	if(obj != null && obj instanceof Student) {
		return toString().equals(obj.toString());
	}else {
		return false;
	}
}	

@Override
public int hashCode() {
	return toString().hashCode();
}


